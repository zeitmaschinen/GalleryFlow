import os\nimport logging\nfrom pathlib import Path\nfrom PIL import Image as PILImage\nfrom PIL import ImageOps\nfrom typing import Tuple, Optional\n\nlogger = logging.getLogger(__name__)\n\nclass ThumbnailGenerator:\n    def __init__(self, thumbnail_dir: str = \"thumbnails\", max_size: Tuple[int, int] = (300, 300)):\n        self.thumbnail_dir = Path(thumbnail_dir)\n        self.max_size = max_size\n        self.thumbnail_dir.mkdir(exist_ok=True)\n        \n        # Create subdirectories for different sizes\n        (self.thumbnail_dir / \"small\").mkdir(exist_ok=True)  # 150x150\n        (self.thumbnail_dir / \"medium\").mkdir(exist_ok=True)  # 300x300\n        \n    def generate_thumbnail(self, image_path: str, size: str = \"medium\") -> Optional[str]:\n        \"\"\"Generate thumbnail for an image and return the thumbnail path.\"\"\"\n        try:\n            source_path = Path(image_path)\n            if not source_path.exists() or not source_path.is_file():\n                logger.warning(f\"Source image not found: {image_path}\")\n                return None\n                \n            # Determine thumbnail size\n            if size == \"small\":\n                thumb_size = (150, 150)\n                size_dir = \"small\"\n            else:\n                thumb_size = (300, 300)\n                size_dir = \"medium\"\n                \n            # Generate thumbnail filename\n            thumb_filename = f\"{source_path.stem}_{source_path.stat().st_mtime:.0f}.webp\"\n            thumb_path = self.thumbnail_dir / size_dir / thumb_filename\n            \n            # Skip if thumbnail already exists and is newer than source\n            if thumb_path.exists():\n                thumb_mtime = thumb_path.stat().st_mtime\n                source_mtime = source_path.stat().st_mtime\n                if thumb_mtime >= source_mtime:\n                    return str(thumb_path)\n                    \n            # Open and process image\n            with PILImage.open(source_path) as img:\n                # Convert to RGB if necessary (handles RGBA, P mode, etc.)\n                if img.mode in ('RGBA', 'LA', 'P'):\n                    # Create white background for transparent images\n                    background = PILImage.new('RGB', img.size, (255, 255, 255))\n                    if img.mode == 'P':\n                        img = img.convert('RGBA')\n                    background.paste(img, mask=img.split()[-1] if img.mode in ('RGBA', 'LA') else None)\n                    img = background\n                elif img.mode != 'RGB':\n                    img = img.convert('RGB')\n                    \n                # Generate thumbnail with proper aspect ratio\n                img.thumbnail(thumb_size, PILImage.Resampling.LANCZOS)\n                \n                # Add slight sharpening for better thumbnail quality\n                img = ImageOps.exif_transpose(img)  # Handle EXIF rotation\n                \n                # Save as WebP for better compression\n                img.save(thumb_path, 'WEBP', quality=85, optimize=True)\n                \n                logger.info(f\"Generated thumbnail: {thumb_path}\")\n                return str(thumb_path)\n                \n        except Exception as e:\n            logger.error(f\"Failed to generate thumbnail for {image_path}: {e}\")\n            return None\n            \n    def get_image_dimensions(self, image_path: str) -> Tuple[Optional[int], Optional[int]]:\n        \"\"\"Get image dimensions without loading the full image.\"\"\"\n        try:\n            with PILImage.open(image_path) as img:\n                return img.width, img.height\n        except Exception as e:\n            logger.error(f\"Failed to get dimensions for {image_path}: {e}\")\n            return None, None\n            \n    def get_file_size(self, image_path: str) -> Optional[int]:\n        \"\"\"Get file size in bytes.\"\"\"\n        try:\n            return Path(image_path).stat().st_size\n        except Exception as e:\n            logger.error(f\"Failed to get file size for {image_path}: {e}\")\n            return None\n            \n    def cleanup_orphaned_thumbnails(self, valid_image_paths: set):\n        \"\"\"Remove thumbnails for images that no longer exist.\"\"\"\n        try:\n            for size_dir in [\"small\", \"medium\"]:\n                thumb_dir = self.thumbnail_dir / size_dir\n                if not thumb_dir.exists():\n                    continue\n                    \n                for thumb_file in thumb_dir.glob(\"*.webp\"):\n                    # Extract original filename from thumbnail name\n                    thumb_name = thumb_file.stem\n                    if '_' in thumb_name:\n                        original_name = '_'.join(thumb_name.split('_')[:-1])\n                        \n                        # Check if any valid image matches this thumbnail\n                        is_orphaned = True\n                        for image_path in valid_image_paths:\n                            if Path(image_path).stem == original_name:\n                                is_orphaned = False\n                                break\n                                \n                        if is_orphaned:\n                            thumb_file.unlink()\n                            logger.info(f\"Removed orphaned thumbnail: {thumb_file}\")\n                            \n        except Exception as e:\n            logger.error(f\"Error during thumbnail cleanup: {e}\")\n\n# Global thumbnail generator instance\nthumbnail_generator = ThumbnailGenerator()\n